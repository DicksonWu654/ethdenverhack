{"text": "Does this solidity smart contract have a vulnerability to re-entry attacks: contract EtherStore { uint256 public withdrawalLimit = 1 ether; mapping(address => uint256) public lastWithdrawTime; mapping(address => uint256) public balances; function depositFunds() public payable { balances[msg.sender] += msg.value; } function withdrawFunds (uint256 _weiToWithdraw) public { require(balances[msg.sender] >= _weiToWithdraw); require(_weiToWithdraw <= withdrawalLimit); require(now >= lastWithdrawTime[msg.sender] + 1 weeks); require(msg.sender.call.value(_weiToWithdraw)()); balances[msg.sender] -= _weiToWithdraw; lastWithdrawTime[msg.sender] = now; } }", "label": "Yes"}
{"text": "Does this solidity smart contract have a vulnerability to re-entry attacks: contract EtherStore { mapping(address => uint256) public balances; function transfer(address to, uint256 amount) external { require(!lock); lock = true; if (balances[msg.sender] >= amount) { balances[to] += amount; balances[msg.sender] -= amount; } lock = false; } function withdraw() external { require(!lock); lock = true; uint256 amount = balances[msg.sender]; require(msg.sender.call.value(amount)()); balances[msg.sender] = 0; lock = false; } }", "label": "No"}
{"text": "Does this solidity smart contract have a vulnerability to re-entry attacks: contract HoneyPot { mapping (address => uint) public balances; function HoneyPot() payable { put(); } function put() payable { balances[msg.sender] = msg.value; } function get() { if (!msg.sender.call.value(balances[msg.sender])()) { throw; } balances[msg.sender] = 0; } function() { throw; } }", "label": "Yes"}
{"text": "Does this solidity smart contract have a vulnerability to re-entry attacks: contract HoneyPot { mapping (address => uint) public balances; bool lock = false; function HoneyPot() payable { put(); } function put() payable { balances[msg.sender] = msg.value; } function get() { if (!lock) { throw; } lock = true; if (!msg.sender.call.value(balances[msg.sender])()) { throw; } balances[msg.sender] = 0; lock = false; } function() { throw; } }", "label": "No"}
{"text": "Does this solidity smart contract have a vulnerability to re-entry attacks: contract VulnerableBank { mapping (address=>uint256) balance; function deposit () external payable { balance[msg.sender]+=msg.value; } function withdraw () external payable{ require(balance[msg.sender]>=0,'Not enough ether'); payable(msg.sender).call{value:balance[msg.sender]}(\"\"); balance[msg.sender]=0; } function banksBalance () public view returns (uint256){ return address(this).balance; } function userBalance (address _address) public view returns (uint256){ return balance[_address]; } }", "label": "Yes"}
{"text": "Does this solidity smart contract have a vulnerability to re-entry attacks: contract EtherStore { mapping(address => uint) public balances; function deposit() public payable { balances[msg.sender] += msg.value; } function withdraw() public { uint bal = balances[msg.sender]; require(bal > 0); (bool sent, ) = msg.sender.call{value: bal}(\"\"); require(sent, \"Failed to send Ether\"); balances[msg.sender] = 0; } function getBalance() public view returns (uint) { return address(this).balance; } }", "label": "Yes"}
{"text": "Does this solidity smart contract have a vulnerability to re-entry attacks: contract EtherStore { mapping(address => uint256) public balances; function transfer(address to, uint256 amount) external { if (balances[msg.sender] >= amount) { balances[to] += amount; balances[msg.sender] -= amount; } } function withdraw() external { uint256 amount = balances[msg.sender]; balances[msg.sender] = 0; require(msg.sender.call.value(amount)()); } }", "label": "No"}
{"text": "Does this solidity smart contract have a vulnerability to re-entry attacks: contract EtherStore { mapping(address => uint256) public balances; function transfer(address to, uint256 amount) external { if (balances[msg.sender] >= amount) { balances[to] += amount; balances[msg.sender] -= amount; } } function withdraw() external { uint256 amount = balances[msg.sender]; require(msg.sender.call.value(amount)()); balances[msg.sender] = 0; } }", "label": "Yes"}
{"text": "Does this solidity smart contract have a vulnerability to re-entry attacks: contract Token { mapping (address => uint) tokenBalance; mapping (address => uint) etherBalance; uint currentRate; constructor() public { /*function Token() public {*/ currentRate = 2; } function getTokenCountFor(address x) public view returns(uint) { return tokenBalance[x]; } function getEtherCountFor(address x) public view returns(uint) { return etherBalance[x]; } function getTokenCount() public view returns(uint) { return tokenBalance[msg.sender]; } function depositEther() public payable { if (msg.value > 0) { etherBalance[msg.sender] += msg.value; } } function exchangeTokens(uint amount) public { if (tokenBalance[msg.sender] >= amount) { uint etherAmount = amount * currentRate; etherBalance[msg.sender] += etherAmount; tokenBalance[msg.sender] -= amount; } } function exchangeEther(uint amount) public payable { etherBalance[msg.sender] += msg.value; if (etherBalance[msg.sender] >= amount) { uint tokenAmount = amount / currentRate; etherBalance[msg.sender] -= amount; tokenBalance[msg.sender] += tokenAmount; } } function transferToken(address to, uint amount) public { if (tokenBalance[msg.sender] >= amount) { tokenBalance[to] += amount; tokenBalance[msg.sender] -= amount; } } function exchangeAndWithdrawToken(uint amount) public { if (tokenBalance[msg.sender] >= amount) { uint etherAmount = tokenBalance[msg.sender] * currentRate; tokenBalance[msg.sender] -= amount; msg.sender.transfer(etherAmount); } } function withdrawAll() public { uint etherAmount = etherBalance[msg.sender]; uint tokenAmount = tokenBalance[msg.sender]; if (etherAmount > 0 && tokenAmount > 0) { uint e = etherAmount + (tokenAmount * currentRate); etherBalance[msg.sender] = 0; msg.sender.call.value(e)(\"\"); tokenBalance[msg.sender] = 0; } } }", "label": "Ye"}
