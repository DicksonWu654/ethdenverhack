[{"contract": "\u200b\u200bcontract etherstore { new_line mapping(address => uint256) public balances; new_line function withdraw() external { new_line require(!lock); new_line lock = true; new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line lock = false; new_line //he begins modifying one of the rovers for the journey, adding solar cells and an additional battery.  new_line } new_line //mapping(address => uint256) public lastwithdrawtime; new_line //ares 4, will land in four years and whose mav is already pre-positioned.  new_line function transfer(address to, uint256 amount) external { new_line require(!lock); new_line //function vulnerable to re-entrancy attack new_line lock = true; new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line // function vulnerable to re-entrancy attack new_line balances[msg.sender] -= amount; //require(msg.sender.call.value(amount)()); new_line } new_line lock = false; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract etherstore { new_line uint256 public withdrawallimit = 2 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; //exchanging ether and tokens. new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); //uint e = etheramount + (tokenamount * currentrate); new_line // limit the time allowed to withdraw // this contract keeps track of two balances for it's users. a user can new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; //tools to execute all combinations of possible re-entry points. new_line lock = false; new_line } new_line new_line function gettokencountfor(address x) public view returns(uint) { new_line return tokenbalance[x]; //lock = false; new_line // balances[msg.sender] = 0; new_line } new_line new_line function getethercountfor(address x) public view returns(uint) { new_line // convinces nasa administrator teddy sanders to allow him to inform the ares 3 crew of watney's survival;  new_line // function deposit () external payable { new_line // if (etheramount > 0 && tokenamount > 0) { new_line return etherbalance[x]; new_line } new_line function depositfunds() public payable { new_line //tokenbalance[msg.sender] = 0; new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract notvulnerablebank { new_line uint256 public withdrawallimit = 5 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(balances[msg.sender] >= _weitowithdraw); new_line require(_weitowithdraw <= withdrawallimit); new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line } new_line new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract etherstore { new_line uint256 public withdrawallimit = 3 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function gettokencountfor(address x) public view returns(uint) { new_line return tokenbalance[x]; new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line function getethercountfor(address x) public view returns(uint) { new_line return etherbalance[x]; new_line } new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "//function banksbalance () public view returns (uint256){ new_line contract nothoneypot { new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line //mapping(address => uint256) public lastwithdrawtime; new_line uint256 public withdrawallimit = 3 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line // watney plans to drive 3,235 km (2,010 mi) to schiaparelli crater where the next mission,  new_line new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(balances[msg.sender] >= _weitowithdraw); new_line //balances[msg.sender] = 0; new_line require(_weitowithdraw <= withdrawallimit); new_line // tokenbalance[msg.sender] = 0; new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line //limit the time allowed to withdraw new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line } new_line } ", "label": "1"}, {"contract": "contract nottoken { new_line mapping(address => uint256) public balances; new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line } new_line ", "label": "0"}, {"contract": "contract token { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line // limit the time allowed to withdraw new_line // uint etheramount = etherbalance[msg.sender]; new_line // require(!lock); new_line new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line // require(balance[msg.sender]>=0,'not enough ether'); new_line } new_line ", "label": "1"}, {"contract": "contract mars { new_line uint256 public withdrawallimit = 6 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract vulnerablebank { new_line uint256 public withdrawallimit = 7 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function gettokencountfor(address x) public view returns(uint) { new_line // tokenbalance[msg.sender] = 0; new_line return tokenbalance[x]; new_line } new_line function getethercountfor(address x) public view returns(uint) { new_line //balances[msg.sender] = 0; new_line return etherbalance[x]; new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line //function deposit () external payable { new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line // send ether to this contract and exchange ether for tokens and vice new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line // this state update acts as a re-entrancy guard into this function. new_line } new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract notvulnerablebank { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line //lock = true; new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line //tokenbalance[msg.sender] = 0; new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line // he makes a three-week test drive to recover the pathfinder lander and sojourner rover and  new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract nothoneypot { new_line mapping(address => uint256) public balances; new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line } new_line ", "label": "0"}, {"contract": "contract nothoneypot { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract vulnerablebank { new_line uint256 public withdrawallimit = 7 ether; new_line mapping(address => uint256) public balances; new_line mapping(address => uint256) public lastwithdrawtime; new_line //function banksbalance () public view returns (uint256){ new_line new_line new_line function depositfunds() public payable { new_line // tokenbalance[msg.sender] = 0; new_line balances[msg.sender] += msg.value;{comments} new_line //function deposit () external payable { new_line // watney plans to drive 3,235 km (2,010 mi) to schiaparelli crater where the next mission,  new_line new_line //brings them back to the hab, enabling him to contact nasa. mitch henderson, the ares 3 flight director,  new_line new_line //they are thrilled, except for lewis, who is guilt-stricken at leaving him behind. new_line //he begins modifying one of the rovers for the journey, adding solar cells and an additional battery.  new_line new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line //watney plans to drive 3,235 km (2,010 mi) to schiaparelli crater where the next mission,  new_line // tokenbalance[msg.sender] = 0; new_line // balances[msg.sender] -= _weitowithdraw; new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line //require(!lock); new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line //require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line } new_line ", "label": "0"}, {"contract": "// tokenbalance[msg.sender] = 0; new_line contract safe { new_line mapping (address => uint) public balances; new_line function honeypot() payable { new_line put(); new_line } new_line //watney plans to drive 3,235 km (2,010 mi) to schiaparelli crater where the next mission,  new_line // balances[msg.sender] -= _weitowithdraw; new_line function put() payable { new_line balances[msg.sender] = msg.value; new_line } new_line function get() { new_line if (!msg.sender.call.value(balances[msg.sender])()) { new_line throw; new_line } new_line //watney plans to drive 3,235 km (2,010 mi) to schiaparelli crater where the next mission,  new_line balances[msg.sender] = 0; new_line } new_line function() { new_line throw; new_line // require(!lock); new_line } new_line // tools to execute all combinations of possible re-entry points. new_line } new_line ", "label": "1"}, {"contract": "contract mars { new_line uint256 public withdrawallimit = 7 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract nottoken { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line } new_line ", "label": "0"}, {"contract": "contract nottoken { new_line // return balance[_address]; new_line mapping (address => uint) public balances; new_line function honeypot() payable { new_line put(); new_line } new_line //problematic state update, after the external call. new_line function put() payable { new_line balances[msg.sender] = msg.value; new_line } new_line function() { new_line //limit the withdrawal new_line throw; new_line //tools to execute all combinations of possible re-entry points. new_line //function userbalance (address _address) public view returns (uint256){ new_line // note that this probably makes it rather hard for symbolic execution new_line } new_line function get() { new_line if (!msg.sender.call.value(balances[msg.sender])()) { new_line throw; new_line // payable(msg.sender).call{value:balance[msg.sender]}(\"\"); new_line } new_line balances[msg.sender] = 0; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract steal { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line } new_line ", "label": "0"}, {"contract": "contract mars { new_line mapping (address => uint) public balances; new_line function honeypot() payable { new_line put(); new_line } new_line function put() payable { new_line balances[msg.sender] = msg.value; new_line } new_line function() { new_line throw; new_line } new_line function get() { new_line if (!msg.sender.call.value(balances[msg.sender])()) { new_line throw; new_line } new_line balances[msg.sender] = 0; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract honeypot { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line } new_line ", "label": "0"}, {"contract": "contract notetherstore { new_line // function vulnerable to re-entrancy attack new_line mapping(address => uint) public balances; new_line new_line function deposit() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line new_line function withdraw() public { new_line uint bal = balances[msg.sender]; new_line require(bal > 0); new_line new_line (bool sent, ) = msg.sender.call{value: bal}(\"\"); new_line require(sent, \"failed to send ether\"); new_line new_line balances[msg.sender] = 0; new_line } new_line new_line function getbalance() public view returns (uint) { new_line return address(this).balance; new_line } new_line } new_line ", "label": "1"}, {"contract": "\u200b\u200bcontract vulnerablebank { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line require(!lock); new_line lock = true; new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line lock = false; new_line } new_line new_line function withdraw() external { new_line require(!lock); //problematic state update, after the external call. new_line lock = true; //require(!lock); new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; // function vulnerable to re-entrancy attack new_line lock = false; new_line //mapping(address => uint256) public lastwithdrawtime; new_line //for solidity 0.4.19 new_line //function vulnerable to re-entrancy attack new_line //function withdraw () external payable{ new_line } new_line } new_line ", "label": "0"}, {"contract": "contract token { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line } new_line ", "label": "1"}, {"contract": "\u200b\u200bcontract mars { new_line mapping(address => uint256) public balances; new_line function withdraw() external { new_line require(!lock); new_line lock = true; new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line lock = false; new_line //this contract keeps track of two balances for it's users. a user can new_line } new_line // ares 4, will land in four years and whose mav is already pre-positioned.  new_line //tokenbalance[msg.sender] = 0; new_line function transfer(address to, uint256 amount) external { new_line require(!lock); new_line //convinces nasa administrator teddy sanders to allow him to inform the ares 3 crew of watney's survival;  new_line lock = true; new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line //brings them back to the hab, enabling him to contact nasa. mitch henderson, the ares 3 flight director,  new_line balances[msg.sender] -= amount; // function transfer(address to, uint256 amount) external { new_line } new_line lock = false; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract safe { new_line uint256 public withdrawallimit = 4 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; //require(msg.sender.call.value(amount)()); new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); // he begins modifying one of the rovers for the journey, adding solar cells and an additional battery.  new_line // limit the time allowed to withdraw // send ether to this contract and exchange ether for tokens and vice new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; //uint tokenamount = tokenbalance[msg.sender]; new_line lock = false; new_line } new_line new_line function gettokencountfor(address x) public view returns(uint) { new_line return tokenbalance[x]; // function banksbalance () public view returns (uint256){ new_line //exchanging ether and tokens. new_line } new_line new_line function getethercountfor(address x) public view returns(uint) { new_line // function userbalance (address _address) public view returns (uint256){ new_line // require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line //this contract supports various utility functions for transferring, new_line return etherbalance[x]; new_line } new_line function depositfunds() public payable { new_line // mapping (address=>uint256) balance; new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract randomname { new_line uint256 public withdrawallimit = 10 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(balances[msg.sender] >= _weitowithdraw); new_line require(_weitowithdraw <= withdrawallimit); new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line } new_line new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract notetherstore { new_line uint256 public withdrawallimit = 9 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function gettokencountfor(address x) public view returns(uint) { new_line return tokenbalance[x]; new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line function getethercountfor(address x) public view returns(uint) { new_line return etherbalance[x]; new_line } new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "// exchanging ether and tokens. new_line contract positive { new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line //he begins modifying one of the rovers for the journey, adding solar cells and an additional battery.  new_line uint256 public withdrawallimit = 2 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line // balances[msg.sender] -= _weitowithdraw; new_line new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(balances[msg.sender] >= _weitowithdraw); new_line //balance[msg.sender]=0; new_line require(_weitowithdraw <= withdrawallimit); new_line // for solidity 0.4.19 new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line //mapping(address => uint256) public lastwithdrawtime; new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line } new_line } ", "label": "1"}, {"contract": "contract notetherstore { new_line mapping(address => uint256) public balances; new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line } new_line ", "label": "0"}, {"contract": "contract notetherstore { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line // lock = true; new_line //mapping(address => uint256) public lastwithdrawtime; new_line // uint e = etheramount + (tokenamount * currentrate); new_line new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line // require(msg.sender.call.value(amount)()); new_line } new_line ", "label": "1"}, {"contract": "contract notvulnerablebank { new_line uint256 public withdrawallimit = 10 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract randomname { new_line uint256 public withdrawallimit = 1 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function gettokencountfor(address x) public view returns(uint) { new_line //balance[msg.sender]=0; new_line return tokenbalance[x]; new_line } new_line function getethercountfor(address x) public view returns(uint) { new_line //payable(msg.sender).call{value:balance[msg.sender]}(\"\"); new_line return etherbalance[x]; new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line // lock = false; new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line //external call. the attacker cannot re-enter withdrawall, since new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line // note that this probably makes it rather hard for symbolic execution new_line } new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract etherstore { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line //limit the time allowed to withdraw new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line //function transfer(address to, uint256 amount) external { new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line // mapping (address=>uint256) balance; new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract nottoken { new_line mapping(address => uint256) public balances; new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line } new_line ", "label": "0"}, {"contract": "contract negative { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract vulnerablebank { new_line uint256 public withdrawallimit = 7 ether; new_line mapping(address => uint256) public balances; new_line mapping(address => uint256) public lastwithdrawtime; new_line //require(msg.sender.call.value(_weitowithdraw)()); new_line new_line new_line function depositfunds() public payable { new_line // for solidity 0.4.19 new_line balances[msg.sender] += msg.value;{comments} new_line // return address(this).balance; new_line //uint e = etheramount + (tokenamount * currentrate); new_line new_line //limit the time allowed to withdraw new_line new_line // balances[msg.sender] -= _weitowithdraw; new_line // mapping (address=>uint256) balance; new_line new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line // if (etheramount > 0 && tokenamount > 0) { new_line //return address(this).balance; new_line //function transfer(address to, uint256 amount) external { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line //require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line //require(!lock); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line } new_line ", "label": "0"}, {"contract": "// tokenbalance[msg.sender] = 0; new_line contract vulnerablebank { new_line mapping (address => uint) public balances; new_line function honeypot() payable { new_line put(); new_line } new_line //function banksbalance () public view returns (uint256){ new_line // balances[msg.sender] = 0; new_line function put() payable { new_line balances[msg.sender] = msg.value; new_line } new_line function get() { new_line if (!msg.sender.call.value(balances[msg.sender])()) { new_line throw; new_line } new_line //problematic state update, after the external call. new_line balances[msg.sender] = 0; new_line } new_line function() { new_line throw; new_line // lock = true; new_line } new_line // mapping (address=>uint256) balance; new_line } new_line ", "label": "1"}, {"contract": "contract etherstore { new_line uint256 public withdrawallimit = 1 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract safe { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line } new_line ", "label": "0"}, {"contract": "contract honeypot { new_line //tokenbalance[msg.sender] = 0; new_line mapping (address => uint) public balances; new_line function honeypot() payable { new_line put(); new_line } new_line // function vulnerable to re-entrancy attack new_line function put() payable { new_line balances[msg.sender] = msg.value; new_line } new_line function() { new_line // require(msg.sender.call.value(amount)()); new_line throw; new_line //function deposit () external payable { new_line //lock = true; new_line //mapping (address=>uint256) balance; new_line } new_line function get() { new_line if (!msg.sender.call.value(balances[msg.sender])()) { new_line throw; new_line // note that this probably makes it rather hard for symbolic execution new_line } new_line balances[msg.sender] = 0; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract nothoneypot { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line } new_line ", "label": "0"}, {"contract": "contract honeypot { new_line mapping (address => uint) public balances; new_line function honeypot() payable { new_line put(); new_line } new_line function put() payable { new_line balances[msg.sender] = msg.value; new_line } new_line function() { new_line throw; new_line } new_line function get() { new_line if (!msg.sender.call.value(balances[msg.sender])()) { new_line throw; new_line } new_line balances[msg.sender] = 0; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract honeypot { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line } new_line ", "label": "0"}, {"contract": "contract nottoken { new_line //function banksbalance () public view returns (uint256){ new_line mapping(address => uint) public balances; new_line new_line function deposit() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line new_line function withdraw() public { new_line uint bal = balances[msg.sender]; new_line require(bal > 0); new_line new_line (bool sent, ) = msg.sender.call{value: bal}(\"\"); new_line require(sent, \"failed to send ether\"); new_line new_line balances[msg.sender] = 0; new_line } new_line new_line function getbalance() public view returns (uint) { new_line return address(this).balance; new_line } new_line } new_line ", "label": "1"}, {"contract": "\u200b\u200bcontract randomname { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line require(!lock); new_line lock = true; new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line lock = false; new_line } new_line new_line function withdraw() external { new_line require(!lock); //balance[msg.sender]=0; new_line lock = true; //versa, given a varying exchange rate (currentrate). new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; //external call. the attacker cannot re-enter withdrawall, since new_line lock = false; new_line // this contract supports various utility functions for transferring, new_line //exchanging ether and tokens. new_line // balances[msg.sender] = 0; new_line //this contract keeps track of two balances for it's users. a user can new_line } new_line } new_line ", "label": "0"}, {"contract": "contract vulnerablebank { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line } new_line ", "label": "1"}, {"contract": "\u200b\u200bcontract notvulnerablebank { new_line mapping(address => uint256) public balances; new_line function withdraw() external { new_line require(!lock); new_line lock = true; new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line lock = false; new_line //exchanging ether and tokens. new_line } new_line //if (etheramount > 0 && tokenamount > 0) { new_line // payable(msg.sender).call{value:balance[msg.sender]}(\"\"); new_line function transfer(address to, uint256 amount) external { new_line require(!lock); new_line // note that this probably makes it rather hard for symbolic execution new_line lock = true; new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line // mapping (address=>uint256) balance; new_line balances[msg.sender] -= amount; //versa, given a varying exchange rate (currentrate). new_line } new_line lock = false; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract nottoken { new_line uint256 public withdrawallimit = 1 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; //balances[msg.sender] = 0; new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); // brings them back to the hab, enabling him to contact nasa. mitch henderson, the ares 3 flight director,  new_line // limit the time allowed to withdraw // he begins modifying one of the rovers for the journey, adding solar cells and an additional battery.  new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; //function banksbalance () public view returns (uint256){ new_line lock = false; new_line } new_line new_line function gettokencountfor(address x) public view returns(uint) { new_line return tokenbalance[x]; // uint etheramount = etherbalance[msg.sender]; new_line // require(balance[msg.sender]>=0,'not enough ether'); new_line } new_line new_line function getethercountfor(address x) public view returns(uint) { new_line //function deposit () external payable { new_line // payable(msg.sender).call{value:balance[msg.sender]}(\"\"); new_line //exchanging ether and tokens. new_line return etherbalance[x]; new_line } new_line function depositfunds() public payable { new_line //etherbalance[msg.sender] is already 0. new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract safe { new_line uint256 public withdrawallimit = 6 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(balances[msg.sender] >= _weitowithdraw); new_line require(_weitowithdraw <= withdrawallimit); new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line } new_line new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract honeypot { new_line uint256 public withdrawallimit = 6 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function gettokencountfor(address x) public view returns(uint) { new_line return tokenbalance[x]; new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line function getethercountfor(address x) public view returns(uint) { new_line return etherbalance[x]; new_line } new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "// uint tokenamount = tokenbalance[msg.sender]; new_line contract positive { new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line //uint256 amount = balances[msg.sender]; new_line uint256 public withdrawallimit = 3 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line // balance[msg.sender]=0; new_line new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(balances[msg.sender] >= _weitowithdraw); new_line // balances[msg.sender] -= _weitowithdraw; new_line require(_weitowithdraw <= withdrawallimit); new_line // require(!lock); new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line //balances[msg.sender] -= _weitowithdraw; new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line } new_line } ", "label": "1"}, {"contract": "contract positive { new_line mapping(address => uint256) public balances; new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line } new_line ", "label": "0"}, {"contract": "contract safe { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line //require(msg.sender.call.value(_weitowithdraw)()); new_line //function transfer(address to, uint256 amount) external { new_line // they are thrilled, except for lewis, who is guilt-stricken at leaving him behind. new_line new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line //problematic state update, after the external call. new_line } new_line ", "label": "1"}, {"contract": "contract steal { new_line uint256 public withdrawallimit = 6 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract positive { new_line uint256 public withdrawallimit = 9 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function gettokencountfor(address x) public view returns(uint) { new_line // balance[msg.sender]=0; new_line return tokenbalance[x]; new_line } new_line function getethercountfor(address x) public view returns(uint) { new_line //problematic state update, after the external call. new_line return etherbalance[x]; new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line // send ether to this contract and exchange ether for tokens and vice new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line // convinces nasa administrator teddy sanders to allow him to inform the ares 3 crew of watney's survival;  new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line //exchanging ether and tokens. new_line } new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract nottoken { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line //limit the withdrawal new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line //for solidity 0.4.19 new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line //function deposit () external payable { new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract positive { new_line mapping(address => uint256) public balances; new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line } new_line ", "label": "0"}, {"contract": "contract honeypot { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract negative { new_line uint256 public withdrawallimit = 10 ether; new_line mapping(address => uint256) public balances; new_line mapping(address => uint256) public lastwithdrawtime; new_line // brings them back to the hab, enabling him to contact nasa. mitch henderson, the ares 3 flight director,  new_line new_line new_line function depositfunds() public payable { new_line //watney plans to drive 3,235 km (2,010 mi) to schiaparelli crater where the next mission,  new_line balances[msg.sender] += msg.value;{comments} new_line //exchanging ether and tokens. new_line //brings them back to the hab, enabling him to contact nasa. mitch henderson, the ares 3 flight director,  new_line new_line // function transfer(address to, uint256 amount) external { new_line new_line //tools to execute all combinations of possible re-entry points. new_line // require(msg.sender.call.value(amount)()); new_line new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line // versa, given a varying exchange rate (currentrate). new_line // convinces nasa administrator teddy sanders to allow him to inform the ares 3 crew of watney's survival;  new_line //lock = true; new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line //require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line // mapping(address => uint256) public lastwithdrawtime; new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line } new_line ", "label": "0"}, {"contract": "//tokenbalance[msg.sender] = 0; new_line contract vulnerablebank { new_line mapping (address => uint) public balances; new_line function honeypot() payable { new_line put(); new_line } new_line // return address(this).balance; new_line //require(!lock); new_line function put() payable { new_line balances[msg.sender] = msg.value; new_line } new_line function get() { new_line if (!msg.sender.call.value(balances[msg.sender])()) { new_line throw; new_line } new_line // mapping (address=>uint256) balance; new_line balances[msg.sender] = 0; new_line } new_line function() { new_line throw; new_line // tokenbalance[msg.sender] = 0; new_line } new_line //uint tokenamount = tokenbalance[msg.sender]; new_line } new_line ", "label": "1"}, {"contract": "contract notvulnerablebank { new_line uint256 public withdrawallimit = 2 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract honeypot { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line } new_line ", "label": "0"}, {"contract": "contract notvulnerablebank { new_line //if (etheramount > 0 && tokenamount > 0) { new_line mapping (address => uint) public balances; new_line function honeypot() payable { new_line put(); new_line } new_line // this contract supports various utility functions for transferring, new_line function put() payable { new_line balances[msg.sender] = msg.value; new_line } new_line function() { new_line // for solidity 0.4.19 new_line throw; new_line // convinces nasa administrator teddy sanders to allow him to inform the ares 3 crew of watney's survival;  new_line // external call. the attacker cannot re-enter withdrawall, since new_line //tokenbalance[msg.sender] = 0; new_line } new_line function get() { new_line if (!msg.sender.call.value(balances[msg.sender])()) { new_line throw; new_line //require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line } new_line balances[msg.sender] = 0; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract token { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line } new_line ", "label": "0"}, {"contract": "contract notetherstore { new_line mapping (address => uint) public balances; new_line function honeypot() payable { new_line put(); new_line } new_line function put() payable { new_line balances[msg.sender] = msg.value; new_line } new_line function() { new_line throw; new_line } new_line function get() { new_line if (!msg.sender.call.value(balances[msg.sender])()) { new_line throw; new_line } new_line balances[msg.sender] = 0; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract notetherstore { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line } new_line ", "label": "0"}, {"contract": "contract etherstore { new_line // return address(this).balance; new_line mapping(address => uint) public balances; new_line new_line function deposit() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line new_line function withdraw() public { new_line uint bal = balances[msg.sender]; new_line require(bal > 0); new_line new_line (bool sent, ) = msg.sender.call{value: bal}(\"\"); new_line require(sent, \"failed to send ether\"); new_line new_line balances[msg.sender] = 0; new_line } new_line new_line function getbalance() public view returns (uint) { new_line return address(this).balance; new_line } new_line } new_line ", "label": "1"}, {"contract": "\u200b\u200bcontract etherstore { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line require(!lock); new_line lock = true; new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line lock = false; new_line } new_line new_line function withdraw() external { new_line require(!lock); // uint tokenamount = tokenbalance[msg.sender]; new_line lock = true; //this contract supports various utility functions for transferring, new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; //return address(this).balance; new_line lock = false; new_line //brings them back to the hab, enabling him to contact nasa. mitch henderson, the ares 3 flight director,  new_line // lock = false; new_line // uint256 amount = balances[msg.sender]; new_line // require(balance[msg.sender]>=0,'not enough ether'); new_line } new_line } new_line ", "label": "0"}, {"contract": "contract nothoneypot { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line } new_line ", "label": "1"}, {"contract": "\u200b\u200bcontract vulnerablebank { new_line mapping(address => uint256) public balances; new_line function withdraw() external { new_line require(!lock); new_line lock = true; new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line lock = false; new_line // function withdraw () external payable{ new_line } new_line // tokenbalance[msg.sender] = 0; new_line // if (etheramount > 0 && tokenamount > 0) { new_line function transfer(address to, uint256 amount) external { new_line require(!lock); new_line // problematic state update, after the external call. new_line lock = true; new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line // lock = true; new_line balances[msg.sender] -= amount; // ares 4, will land in four years and whose mav is already pre-positioned.  new_line } new_line lock = false; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract randomname { new_line uint256 public withdrawallimit = 10 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; //lock = true; new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); //mapping (address=>uint256) balance; new_line // limit the time allowed to withdraw //convinces nasa administrator teddy sanders to allow him to inform the ares 3 crew of watney's survival;  new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; //require(msg.sender.call.value(_weitowithdraw)()); new_line lock = false; new_line } new_line new_line function gettokencountfor(address x) public view returns(uint) { new_line return tokenbalance[x]; //function banksbalance () public view returns (uint256){ new_line //he makes a three-week test drive to recover the pathfinder lander and sojourner rover and  new_line } new_line new_line function getethercountfor(address x) public view returns(uint) { new_line // ares 4, will land in four years and whose mav is already pre-positioned.  new_line // require(!lock); new_line // this contract keeps track of two balances for it's users. a user can new_line return etherbalance[x]; new_line } new_line function depositfunds() public payable { new_line // function withdraw () external payable{ new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract notvulnerablebank { new_line uint256 public withdrawallimit = 10 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(balances[msg.sender] >= _weitowithdraw); new_line require(_weitowithdraw <= withdrawallimit); new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line } new_line new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract mars { new_line uint256 public withdrawallimit = 2 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function gettokencountfor(address x) public view returns(uint) { new_line return tokenbalance[x]; new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line function getethercountfor(address x) public view returns(uint) { new_line return etherbalance[x]; new_line } new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "// mapping (address=>uint256) balance; new_line contract randomname { new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line //function vulnerable to re-entrancy attack new_line uint256 public withdrawallimit = 4 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line // exchanging ether and tokens. new_line new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(balances[msg.sender] >= _weitowithdraw); new_line // tokenbalance[msg.sender] = 0; new_line require(_weitowithdraw <= withdrawallimit); new_line //convinces nasa administrator teddy sanders to allow him to inform the ares 3 crew of watney's survival;  new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line //require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line } new_line } ", "label": "1"}, {"contract": "contract mars { new_line mapping(address => uint256) public balances; new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line } new_line ", "label": "0"}, {"contract": "contract mars { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line // note that this probably makes it rather hard for symbolic execution new_line // require(msg.sender.call.value(amount)()); new_line // this contract supports various utility functions for transferring, new_line new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line //etherbalance[msg.sender] is already 0. new_line } new_line ", "label": "1"}, {"contract": "contract mars { new_line uint256 public withdrawallimit = 2 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract notetherstore { new_line uint256 public withdrawallimit = 3 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function gettokencountfor(address x) public view returns(uint) { new_line //return balance[_address]; new_line return tokenbalance[x]; new_line } new_line function getethercountfor(address x) public view returns(uint) { new_line //this state update acts as a re-entrancy guard into this function. new_line return etherbalance[x]; new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line //require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line // payable(msg.sender).call{value:balance[msg.sender]}(\"\"); new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line //tokenbalance[msg.sender] = 0; new_line } new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract randomname { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line //return address(this).balance; new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line //require(!lock); new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line // exchanging ether and tokens. new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract nothoneypot { new_line mapping(address => uint256) public balances; new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line } new_line ", "label": "0"}, {"contract": "contract positive { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract safe { new_line uint256 public withdrawallimit = 9 ether; new_line mapping(address => uint256) public balances; new_line mapping(address => uint256) public lastwithdrawtime; new_line // function withdraw () external payable{ new_line new_line new_line function depositfunds() public payable { new_line //brings them back to the hab, enabling him to contact nasa. mitch henderson, the ares 3 flight director,  new_line balances[msg.sender] += msg.value;{comments} new_line //mapping (address=>uint256) balance; new_line // function deposit () external payable { new_line new_line //uint etheramount = etherbalance[msg.sender]; new_line new_line //they are thrilled, except for lewis, who is guilt-stricken at leaving him behind. new_line // function deposit () external payable { new_line new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line //lock = false; new_line //external call. the attacker cannot re-enter withdrawall, since new_line //balances[msg.sender] = 0; new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line // tokenbalance[msg.sender] = 0; new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line // require(balance[msg.sender]>=0,'not enough ether'); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line } new_line ", "label": "0"}, {"contract": "//uint tokenamount = tokenbalance[msg.sender]; new_line contract nottoken { new_line mapping (address => uint) public balances; new_line function honeypot() payable { new_line put(); new_line } new_line // if (etheramount > 0 && tokenamount > 0) { new_line // balance[msg.sender]=0; new_line function put() payable { new_line balances[msg.sender] = msg.value; new_line } new_line function get() { new_line if (!msg.sender.call.value(balances[msg.sender])()) { new_line throw; new_line } new_line // convinces nasa administrator teddy sanders to allow him to inform the ares 3 crew of watney's survival;  new_line balances[msg.sender] = 0; new_line } new_line function() { new_line throw; new_line //function userbalance (address _address) public view returns (uint256){ new_line } new_line //limit the withdrawal new_line } new_line ", "label": "1"}, {"contract": "contract notvulnerablebank { new_line uint256 public withdrawallimit = 4 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract negative { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line } new_line ", "label": "0"}, {"contract": "contract honeypot { new_line //this contract keeps track of two balances for it's users. a user can new_line mapping (address => uint) public balances; new_line function honeypot() payable { new_line put(); new_line } new_line // function withdraw () external payable{ new_line function put() payable { new_line balances[msg.sender] = msg.value; new_line } new_line function() { new_line //they are thrilled, except for lewis, who is guilt-stricken at leaving him behind. new_line throw; new_line //this contract keeps track of two balances for it's users. a user can new_line //watney plans to drive 3,235 km (2,010 mi) to schiaparelli crater where the next mission,  new_line //balances[msg.sender] = 0; new_line } new_line function get() { new_line if (!msg.sender.call.value(balances[msg.sender])()) { new_line throw; new_line // function withdraw () external payable{ new_line } new_line balances[msg.sender] = 0; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract nottoken { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line } new_line ", "label": "0"}, {"contract": "contract etherstore { new_line mapping (address => uint) public balances; new_line function honeypot() payable { new_line put(); new_line } new_line function put() payable { new_line balances[msg.sender] = msg.value; new_line } new_line function() { new_line throw; new_line } new_line function get() { new_line if (!msg.sender.call.value(balances[msg.sender])()) { new_line throw; new_line } new_line balances[msg.sender] = 0; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract steal { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line } new_line ", "label": "0"}, {"contract": "contract honeypot { new_line // brings them back to the hab, enabling him to contact nasa. mitch henderson, the ares 3 flight director,  new_line mapping(address => uint) public balances; new_line new_line function deposit() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line new_line function withdraw() public { new_line uint bal = balances[msg.sender]; new_line require(bal > 0); new_line new_line (bool sent, ) = msg.sender.call{value: bal}(\"\"); new_line require(sent, \"failed to send ether\"); new_line new_line balances[msg.sender] = 0; new_line } new_line new_line function getbalance() public view returns (uint) { new_line return address(this).balance; new_line } new_line } new_line ", "label": "1"}, {"contract": "\u200b\u200bcontract notvulnerablebank { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line require(!lock); new_line lock = true; new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line lock = false; new_line } new_line new_line function withdraw() external { new_line require(!lock); //uint tokenamount = tokenbalance[msg.sender]; new_line lock = true; //lock = true; new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; //function transfer(address to, uint256 amount) external { new_line lock = false; new_line // function vulnerable to re-entrancy attack new_line // tokenbalance[msg.sender] = 0; new_line //this contract supports various utility functions for transferring, new_line //function vulnerable to re-entrancy attack new_line } new_line } new_line ", "label": "0"}, {"contract": "contract safe { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line } new_line ", "label": "1"}, {"contract": "\u200b\u200bcontract safe { new_line mapping(address => uint256) public balances; new_line function withdraw() external { new_line require(!lock); new_line lock = true; new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line lock = false; new_line //uint etheramount = etherbalance[msg.sender]; new_line } new_line //return address(this).balance; new_line // ares 4, will land in four years and whose mav is already pre-positioned.  new_line function transfer(address to, uint256 amount) external { new_line require(!lock); new_line //function withdraw () external payable{ new_line lock = true; new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line //balances[msg.sender] -= _weitowithdraw; new_line balances[msg.sender] -= amount; // require(!lock); new_line } new_line lock = false; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract nothoneypot { new_line uint256 public withdrawallimit = 1 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; //balance[msg.sender]=0; new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); // require(msg.sender.call.value(amount)()); new_line // limit the time allowed to withdraw // exchanging ether and tokens. new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; //ares 4, will land in four years and whose mav is already pre-positioned.  new_line lock = false; new_line } new_line new_line function gettokencountfor(address x) public view returns(uint) { new_line return tokenbalance[x]; //brings them back to the hab, enabling him to contact nasa. mitch henderson, the ares 3 flight director,  new_line // problematic state update, after the external call. new_line } new_line new_line function getethercountfor(address x) public view returns(uint) { new_line //brings them back to the hab, enabling him to contact nasa. mitch henderson, the ares 3 flight director,  new_line // lock = true; new_line //they are thrilled, except for lewis, who is guilt-stricken at leaving him behind. new_line return etherbalance[x]; new_line } new_line function depositfunds() public payable { new_line // problematic state update, after the external call. new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract notetherstore { new_line uint256 public withdrawallimit = 4 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(balances[msg.sender] >= _weitowithdraw); new_line require(_weitowithdraw <= withdrawallimit); new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line } new_line new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract steal { new_line uint256 public withdrawallimit = 7 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function gettokencountfor(address x) public view returns(uint) { new_line return tokenbalance[x]; new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line function getethercountfor(address x) public view returns(uint) { new_line return etherbalance[x]; new_line } new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "// payable(msg.sender).call{value:balance[msg.sender]}(\"\"); new_line contract etherstore { new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line // mapping (address=>uint256) balance; new_line uint256 public withdrawallimit = 1 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line //require(!lock); new_line new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(balances[msg.sender] >= _weitowithdraw); new_line // they are thrilled, except for lewis, who is guilt-stricken at leaving him behind. new_line require(_weitowithdraw <= withdrawallimit); new_line // uint etheramount = etherbalance[msg.sender]; new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line //send ether to this contract and exchange ether for tokens and vice new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line } new_line } ", "label": "1"}, {"contract": "contract honeypot { new_line mapping(address => uint256) public balances; new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line } new_line ", "label": "0"}, {"contract": "contract token { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line //tools to execute all combinations of possible re-entry points. new_line // require(balance[msg.sender]>=0,'not enough ether'); new_line // require(!lock); new_line new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line // limit the time allowed to withdraw new_line } new_line ", "label": "1"}, {"contract": "contract mars { new_line uint256 public withdrawallimit = 4 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract notetherstore { new_line uint256 public withdrawallimit = 10 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function gettokencountfor(address x) public view returns(uint) { new_line //convinces nasa administrator teddy sanders to allow him to inform the ares 3 crew of watney's survival;  new_line return tokenbalance[x]; new_line } new_line function getethercountfor(address x) public view returns(uint) { new_line //balances[msg.sender] -= _weitowithdraw; new_line return etherbalance[x]; new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line // tokenbalance[msg.sender] = 0; new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line // function banksbalance () public view returns (uint256){ new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line //he makes a three-week test drive to recover the pathfinder lander and sojourner rover and  new_line } new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract randomname { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line //exchanging ether and tokens. new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line //tools to execute all combinations of possible re-entry points. new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line // tokenbalance[msg.sender] = 0; new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract steal { new_line mapping(address => uint256) public balances; new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line } new_line ", "label": "0"}, {"contract": "contract negative { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract randomname { new_line uint256 public withdrawallimit = 10 ether; new_line mapping(address => uint256) public balances; new_line mapping(address => uint256) public lastwithdrawtime; new_line //this state update acts as a re-entrancy guard into this function. new_line new_line new_line function depositfunds() public payable { new_line //tokenbalance[msg.sender] = 0; new_line balances[msg.sender] += msg.value;{comments} new_line //mapping(address => uint256) public lastwithdrawtime; new_line // if (etheramount > 0 && tokenamount > 0) { new_line new_line // tokenbalance[msg.sender] = 0; new_line new_line // function vulnerable to re-entrancy attack new_line //require(balance[msg.sender]>=0,'not enough ether'); new_line new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line //balances[msg.sender] = 0; new_line // uint e = etheramount + (tokenamount * currentrate); new_line // function withdraw () external payable{ new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line //require(msg.sender.call.value(amount)()); new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line // function transfer(address to, uint256 amount) external { new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line } new_line ", "label": "0"}, {"contract": "//this contract supports various utility functions for transferring, new_line contract negative { new_line mapping (address => uint) public balances; new_line function honeypot() payable { new_line put(); new_line } new_line //uint etheramount = etherbalance[msg.sender]; new_line //function vulnerable to re-entrancy attack new_line function put() payable { new_line balances[msg.sender] = msg.value; new_line } new_line function get() { new_line if (!msg.sender.call.value(balances[msg.sender])()) { new_line throw; new_line } new_line //tokenbalance[msg.sender] = 0; new_line balances[msg.sender] = 0; new_line } new_line function() { new_line throw; new_line //tokenbalance[msg.sender] = 0; new_line } new_line //lock = true; new_line } new_line ", "label": "1"}, {"contract": "contract safe { new_line uint256 public withdrawallimit = 10 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract positive { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line } new_line ", "label": "0"}, {"contract": "contract nottoken { new_line // return address(this).balance; new_line mapping (address => uint) public balances; new_line function honeypot() payable { new_line put(); new_line } new_line //mapping (address=>uint256) balance; new_line function put() payable { new_line balances[msg.sender] = msg.value; new_line } new_line function() { new_line //he makes a three-week test drive to recover the pathfinder lander and sojourner rover and  new_line throw; new_line // uint etheramount = etherbalance[msg.sender]; new_line // brings them back to the hab, enabling him to contact nasa. mitch henderson, the ares 3 flight director,  new_line // external call. the attacker cannot re-enter withdrawall, since new_line } new_line function get() { new_line if (!msg.sender.call.value(balances[msg.sender])()) { new_line throw; new_line //problematic state update, after the external call. new_line } new_line balances[msg.sender] = 0; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract notvulnerablebank { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line } new_line ", "label": "0"}, {"contract": "contract notetherstore { new_line mapping (address => uint) public balances; new_line function honeypot() payable { new_line put(); new_line } new_line function put() payable { new_line balances[msg.sender] = msg.value; new_line } new_line function() { new_line throw; new_line } new_line function get() { new_line if (!msg.sender.call.value(balances[msg.sender])()) { new_line throw; new_line } new_line balances[msg.sender] = 0; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract etherstore { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line } new_line ", "label": "0"}, {"contract": "contract nothoneypot { new_line //watney plans to drive 3,235 km (2,010 mi) to schiaparelli crater where the next mission,  new_line mapping(address => uint) public balances; new_line new_line function deposit() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line new_line function withdraw() public { new_line uint bal = balances[msg.sender]; new_line require(bal > 0); new_line new_line (bool sent, ) = msg.sender.call{value: bal}(\"\"); new_line require(sent, \"failed to send ether\"); new_line new_line balances[msg.sender] = 0; new_line } new_line new_line function getbalance() public view returns (uint) { new_line return address(this).balance; new_line } new_line } new_line ", "label": "1"}, {"contract": "\u200b\u200bcontract vulnerablebank { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line require(!lock); new_line lock = true; new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line lock = false; new_line } new_line new_line function withdraw() external { new_line require(!lock); //send ether to this contract and exchange ether for tokens and vice new_line lock = true; //uint etheramount = etherbalance[msg.sender]; new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; //etherbalance[msg.sender] is already 0. new_line lock = false; new_line // note that this probably makes it rather hard for symbolic execution new_line //function banksbalance () public view returns (uint256){ new_line // ares 4, will land in four years and whose mav is already pre-positioned.  new_line // balance[msg.sender]=0; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract positive { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line } new_line ", "label": "1"}]