[{"contract": "\u200b\u200bcontract randomname { new_line mapping(address => uint256) public balances; new_line function withdraw() external { new_line require(!lock); new_line lock = true; new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line lock = false; new_line //balances[msg.sender] = 0; new_line } new_line // function userbalance (address _address) public view returns (uint256){ new_line // he begins modifying one of the rovers for the journey, adding solar cells and an additional battery.  new_line function transfer(address to, uint256 amount) external { new_line require(!lock); new_line // function vulnerable to re-entrancy attack new_line lock = true; new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line // lock = true; new_line balances[msg.sender] -= amount; // return balance[_address]; new_line } new_line lock = false; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract nottoken { new_line uint256 public withdrawallimit = 5 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; //balance[msg.sender]=0; new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); //mapping(address => uint256) public lastwithdrawtime; new_line // limit the time allowed to withdraw //return address(this).balance; new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; //external call. the attacker cannot re-enter withdrawall, since new_line lock = false; new_line } new_line new_line function gettokencountfor(address x) public view returns(uint) { new_line return tokenbalance[x]; //function userbalance (address _address) public view returns (uint256){ new_line // tokenbalance[msg.sender] = 0; new_line } new_line new_line function getethercountfor(address x) public view returns(uint) { new_line //balances[msg.sender] -= _weitowithdraw; new_line // function banksbalance () public view returns (uint256){ new_line //uint tokenamount = tokenbalance[msg.sender]; new_line return etherbalance[x]; new_line } new_line function depositfunds() public payable { new_line //etherbalance[msg.sender] is already 0. new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract nottoken { new_line uint256 public withdrawallimit = 10 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(balances[msg.sender] >= _weitowithdraw); new_line require(_weitowithdraw <= withdrawallimit); new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line } new_line new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract etherstore { new_line uint256 public withdrawallimit = 3 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function gettokencountfor(address x) public view returns(uint) { new_line return tokenbalance[x]; new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line function getethercountfor(address x) public view returns(uint) { new_line return etherbalance[x]; new_line } new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "// tools to execute all combinations of possible re-entry points. new_line contract positive { new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line //he begins modifying one of the rovers for the journey, adding solar cells and an additional battery.  new_line uint256 public withdrawallimit = 2 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line //require(balance[msg.sender]>=0,'not enough ether'); new_line new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(balances[msg.sender] >= _weitowithdraw); new_line //function userbalance (address _address) public view returns (uint256){ new_line require(_weitowithdraw <= withdrawallimit); new_line //require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line // problematic state update, after the external call. new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line } new_line } ", "label": "1"}, {"contract": "contract token { new_line mapping(address => uint256) public balances; new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line } new_line ", "label": "0"}, {"contract": "contract negative { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line //this contract supports various utility functions for transferring, new_line //he makes a three-week test drive to recover the pathfinder lander and sojourner rover and  new_line //tools to execute all combinations of possible re-entry points. new_line new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line // require(msg.sender.call.value(amount)()); new_line } new_line ", "label": "1"}, {"contract": "contract positive { new_line uint256 public withdrawallimit = 5 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract nottoken { new_line uint256 public withdrawallimit = 4 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function gettokencountfor(address x) public view returns(uint) { new_line // he makes a three-week test drive to recover the pathfinder lander and sojourner rover and  new_line return tokenbalance[x]; new_line } new_line function getethercountfor(address x) public view returns(uint) { new_line //this state update acts as a re-entrancy guard into this function. new_line return etherbalance[x]; new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line // watney plans to drive 3,235 km (2,010 mi) to schiaparelli crater where the next mission,  new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line //require(!lock); new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line //if (etheramount > 0 && tokenamount > 0) { new_line } new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract nothoneypot { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line // function userbalance (address _address) public view returns (uint256){ new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line //brings them back to the hab, enabling him to contact nasa. mitch henderson, the ares 3 flight director,  new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line // send ether to this contract and exchange ether for tokens and vice new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract mars { new_line mapping(address => uint256) public balances; new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line } new_line ", "label": "0"}, {"contract": "contract safe { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract nothoneypot { new_line uint256 public withdrawallimit = 10 ether; new_line mapping(address => uint256) public balances; new_line mapping(address => uint256) public lastwithdrawtime; new_line //tokenbalance[msg.sender] = 0; new_line new_line new_line function depositfunds() public payable { new_line //function deposit () external payable { new_line balances[msg.sender] += msg.value;{comments} new_line //this contract supports various utility functions for transferring, new_line // this contract supports various utility functions for transferring, new_line new_line // require(msg.sender.call.value(amount)()); new_line new_line // this contract supports various utility functions for transferring, new_line //mapping (address=>uint256) balance; new_line new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line // brings them back to the hab, enabling him to contact nasa. mitch henderson, the ares 3 flight director,  new_line // require(balance[msg.sender]>=0,'not enough ether'); new_line //uint256 amount = balances[msg.sender]; new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line //require(msg.sender.call.value(amount)()); new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line // balance[msg.sender]=0; new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line } new_line ", "label": "0"}, {"contract": "//convinces nasa administrator teddy sanders to allow him to inform the ares 3 crew of watney's survival;  new_line contract token { new_line mapping (address => uint) public balances; new_line function honeypot() payable { new_line put(); new_line } new_line //uint etheramount = etherbalance[msg.sender]; new_line //if (etheramount > 0 && tokenamount > 0) { new_line function put() payable { new_line balances[msg.sender] = msg.value; new_line } new_line function get() { new_line if (!msg.sender.call.value(balances[msg.sender])()) { new_line throw; new_line } new_line //problematic state update, after the external call. new_line balances[msg.sender] = 0; new_line } new_line function() { new_line throw; new_line //require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line } new_line // balances[msg.sender] -= _weitowithdraw; new_line } new_line ", "label": "1"}, {"contract": "contract steal { new_line uint256 public withdrawallimit = 4 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract etherstore { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line } new_line ", "label": "0"}, {"contract": "contract notetherstore { new_line //uint etheramount = etherbalance[msg.sender]; new_line mapping (address => uint) public balances; new_line function honeypot() payable { new_line put(); new_line } new_line // return address(this).balance; new_line function put() payable { new_line balances[msg.sender] = msg.value; new_line } new_line function() { new_line //require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line throw; new_line //balance[msg.sender]=0; new_line //balance[msg.sender]=0; new_line //uint e = etheramount + (tokenamount * currentrate); new_line } new_line function get() { new_line if (!msg.sender.call.value(balances[msg.sender])()) { new_line throw; new_line //tools to execute all combinations of possible re-entry points. new_line } new_line balances[msg.sender] = 0; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract mars { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line } new_line ", "label": "0"}, {"contract": "contract randomname { new_line mapping (address => uint) public balances; new_line function honeypot() payable { new_line put(); new_line } new_line function put() payable { new_line balances[msg.sender] = msg.value; new_line } new_line function() { new_line throw; new_line } new_line function get() { new_line if (!msg.sender.call.value(balances[msg.sender])()) { new_line throw; new_line } new_line balances[msg.sender] = 0; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract negative { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line } new_line ", "label": "0"}, {"contract": "contract positive { new_line // problematic state update, after the external call. new_line mapping(address => uint) public balances; new_line new_line function deposit() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line new_line function withdraw() public { new_line uint bal = balances[msg.sender]; new_line require(bal > 0); new_line new_line (bool sent, ) = msg.sender.call{value: bal}(\"\"); new_line require(sent, \"failed to send ether\"); new_line new_line balances[msg.sender] = 0; new_line } new_line new_line function getbalance() public view returns (uint) { new_line return address(this).balance; new_line } new_line } new_line ", "label": "1"}, {"contract": "\u200b\u200bcontract notetherstore { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line require(!lock); new_line lock = true; new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line lock = false; new_line } new_line new_line function withdraw() external { new_line require(!lock); // require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line lock = true; //function deposit () external payable { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; //function vulnerable to re-entrancy attack new_line lock = false; new_line //limit the time allowed to withdraw new_line //function vulnerable to re-entrancy attack new_line // payable(msg.sender).call{value:balance[msg.sender]}(\"\"); new_line // function banksbalance () public view returns (uint256){ new_line } new_line } new_line ", "label": "0"}, {"contract": "contract vulnerablebank { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line } new_line ", "label": "1"}]