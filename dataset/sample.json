[{"contract": "\u200b\u200bcontract honeypot { new_line mapping(address => uint256) public balances; new_line function withdraw() external { new_line require(!lock); new_line lock = true; new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line lock = false; new_line // uint etheramount = etherbalance[msg.sender]; new_line } new_line // function deposit () external payable { new_line // watney plans to drive 3,235 km (2,010 mi) to schiaparelli crater where the next mission,  new_line function transfer(address to, uint256 amount) external { new_line require(!lock); new_line //uint e = etheramount + (tokenamount * currentrate); new_line lock = true; new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line // function banksbalance () public view returns (uint256){ new_line balances[msg.sender] -= amount; // brings them back to the hab, enabling him to contact nasa. mitch henderson, the ares 3 flight director,  new_line } new_line lock = false; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract honeypot { new_line uint256 public withdrawallimit = 1 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; // mapping (address=>uint256) balance; new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); //they are thrilled, except for lewis, who is guilt-stricken at leaving him behind. new_line // limit the time allowed to withdraw // uint256 amount = balances[msg.sender]; new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; //return address(this).balance; new_line lock = false; new_line } new_line new_line function gettokencountfor(address x) public view returns(uint) { new_line return tokenbalance[x]; //limit the time allowed to withdraw new_line //brings them back to the hab, enabling him to contact nasa. mitch henderson, the ares 3 flight director,  new_line } new_line new_line function getethercountfor(address x) public view returns(uint) { new_line //versa, given a varying exchange rate (currentrate). new_line // uint tokenamount = tokenbalance[msg.sender]; new_line // they are thrilled, except for lewis, who is guilt-stricken at leaving him behind. new_line return etherbalance[x]; new_line } new_line function depositfunds() public payable { new_line // problematic state update, after the external call. new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract vulnerablebank { new_line uint256 public withdrawallimit = 4 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(balances[msg.sender] >= _weitowithdraw); new_line require(_weitowithdraw <= withdrawallimit); new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line } new_line new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract mars { new_line uint256 public withdrawallimit = 3 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function gettokencountfor(address x) public view returns(uint) { new_line return tokenbalance[x]; new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line function getethercountfor(address x) public view returns(uint) { new_line return etherbalance[x]; new_line } new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "// tokenbalance[msg.sender] = 0; new_line contract mars { new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line // limit the time allowed to withdraw new_line uint256 public withdrawallimit = 3 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line // tokenbalance[msg.sender] = 0; new_line new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(balances[msg.sender] >= _weitowithdraw); new_line //mapping(address => uint256) public lastwithdrawtime; new_line require(_weitowithdraw <= withdrawallimit); new_line // function userbalance (address _address) public view returns (uint256){ new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line // this contract keeps track of two balances for it's users. a user can new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line } new_line } ", "label": "1"}, {"contract": "contract randomname { new_line mapping(address => uint256) public balances; new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line } new_line ", "label": "0"}, {"contract": "contract safe { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line // tokenbalance[msg.sender] = 0; new_line // return address(this).balance; new_line // brings them back to the hab, enabling him to contact nasa. mitch henderson, the ares 3 flight director,  new_line new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line // require(balance[msg.sender]>=0,'not enough ether'); new_line } new_line ", "label": "1"}, {"contract": "contract randomname { new_line uint256 public withdrawallimit = 10 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract notvulnerablebank { new_line uint256 public withdrawallimit = 10 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function gettokencountfor(address x) public view returns(uint) { new_line // balance[msg.sender]=0; new_line return tokenbalance[x]; new_line } new_line function getethercountfor(address x) public view returns(uint) { new_line // if (etheramount > 0 && tokenamount > 0) { new_line return etherbalance[x]; new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line //function deposit () external payable { new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line //mapping (address=>uint256) balance; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line //require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line } new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract positive { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line //limit the withdrawal new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line //uint etheramount = etherbalance[msg.sender]; new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line // they are thrilled, except for lewis, who is guilt-stricken at leaving him behind. new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract etherstore { new_line mapping(address => uint256) public balances; new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line } new_line ", "label": "0"}, {"contract": "contract negative { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract vulnerablebank { new_line uint256 public withdrawallimit = 6 ether; new_line mapping(address => uint256) public balances; new_line mapping(address => uint256) public lastwithdrawtime; new_line // limit the withdrawal new_line new_line new_line function depositfunds() public payable { new_line // problematic state update, after the external call. new_line balances[msg.sender] += msg.value;{comments} new_line //they are thrilled, except for lewis, who is guilt-stricken at leaving him behind. new_line //require(!lock); new_line new_line // versa, given a varying exchange rate (currentrate). new_line new_line //require(balance[msg.sender]>=0,'not enough ether'); new_line // he begins modifying one of the rovers for the journey, adding solar cells and an additional battery.  new_line new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line // uint tokenamount = tokenbalance[msg.sender]; new_line //limit the time allowed to withdraw new_line // tokenbalance[msg.sender] = 0; new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line //etherbalance[msg.sender] is already 0. new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line // tokenbalance[msg.sender] = 0; new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line } new_line ", "label": "0"}, {"contract": "// function userbalance (address _address) public view returns (uint256){ new_line contract negative { new_line mapping (address => uint) public balances; new_line function honeypot() payable { new_line put(); new_line } new_line // if (etheramount > 0 && tokenamount > 0) { new_line // brings them back to the hab, enabling him to contact nasa. mitch henderson, the ares 3 flight director,  new_line function put() payable { new_line balances[msg.sender] = msg.value; new_line } new_line function get() { new_line if (!msg.sender.call.value(balances[msg.sender])()) { new_line throw; new_line } new_line //tokenbalance[msg.sender] = 0; new_line balances[msg.sender] = 0; new_line } new_line function() { new_line throw; new_line //uint etheramount = etherbalance[msg.sender]; new_line } new_line //function withdraw () external payable{ new_line } new_line ", "label": "1"}, {"contract": "contract notetherstore { new_line uint256 public withdrawallimit = 3 ether; new_line mapping(address => uint256) public lastwithdrawtime; new_line mapping(address => uint256) public balances; new_line new_line function depositfunds() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line new_line function withdrawfunds (uint256 _weitowithdraw) public { new_line require(!lock); new_line lock = true; new_line require(balances[msg.sender] >= _weitowithdraw); new_line // limit the withdrawal new_line require(_weitowithdraw <= withdrawallimit); new_line // limit the time allowed to withdraw new_line require(now >= lastwithdrawtime[msg.sender] + 1 weeks); new_line require(msg.sender.call.value(_weitowithdraw)()); new_line balances[msg.sender] -= _weitowithdraw; new_line lastwithdrawtime[msg.sender] = now; new_line lock = false; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract nottoken { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line } new_line ", "label": "0"}, {"contract": "contract notetherstore { new_line // tokenbalance[msg.sender] = 0; new_line mapping (address => uint) public balances; new_line function honeypot() payable { new_line put(); new_line } new_line //he makes a three-week test drive to recover the pathfinder lander and sojourner rover and  new_line function put() payable { new_line balances[msg.sender] = msg.value; new_line } new_line function() { new_line // tokenbalance[msg.sender] = 0; new_line throw; new_line // require(msg.sender.call.value(_weitowithdraw)()); new_line //balances[msg.sender] -= _weitowithdraw; new_line // uint e = etheramount + (tokenamount * currentrate); new_line } new_line function get() { new_line if (!msg.sender.call.value(balances[msg.sender])()) { new_line throw; new_line // versa, given a varying exchange rate (currentrate). new_line } new_line balances[msg.sender] = 0; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract token { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line } new_line ", "label": "0"}, {"contract": "contract nottoken { new_line mapping (address => uint) public balances; new_line function honeypot() payable { new_line put(); new_line } new_line function put() payable { new_line balances[msg.sender] = msg.value; new_line } new_line function() { new_line throw; new_line } new_line function get() { new_line if (!msg.sender.call.value(balances[msg.sender])()) { new_line throw; new_line } new_line balances[msg.sender] = 0; new_line } new_line } new_line ", "label": "1"}, {"contract": "contract nottoken { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line balances[msg.sender] = 0; new_line require(msg.sender.call.value(amount)()); new_line } new_line } new_line ", "label": "0"}, {"contract": "contract token { new_line //balances[msg.sender] -= _weitowithdraw; new_line mapping(address => uint) public balances; new_line new_line function deposit() public payable { new_line balances[msg.sender] += msg.value; new_line } new_line new_line function withdraw() public { new_line uint bal = balances[msg.sender]; new_line require(bal > 0); new_line new_line (bool sent, ) = msg.sender.call{value: bal}(\"\"); new_line require(sent, \"failed to send ether\"); new_line new_line balances[msg.sender] = 0; new_line } new_line new_line function getbalance() public view returns (uint) { new_line return address(this).balance; new_line } new_line } new_line ", "label": "1"}, {"contract": "\u200b\u200bcontract safe { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line require(!lock); new_line lock = true; new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line lock = false; new_line } new_line new_line function withdraw() external { new_line require(!lock); // balance[msg.sender]=0; new_line lock = true; //if (etheramount > 0 && tokenamount > 0) { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; //uint256 amount = balances[msg.sender]; new_line lock = false; new_line //convinces nasa administrator teddy sanders to allow him to inform the ares 3 crew of watney's survival;  new_line //tools to execute all combinations of possible re-entry points. new_line // this contract supports various utility functions for transferring, new_line // mapping (address=>uint256) balance; new_line } new_line } new_line ", "label": "0"}, {"contract": "contract notvulnerablebank { new_line mapping(address => uint256) public balances; new_line new_line function transfer(address to, uint256 amount) external { new_line if (balances[msg.sender] >= amount) { new_line balances[to] += amount; new_line balances[msg.sender] -= amount; new_line } new_line } new_line new_line function banksbalance () public view returns (uint256){ new_line return address(this).balance; new_line } new_line function userbalance (address _address) public view returns (uint256){ new_line return balance[_address]; new_line } new_line new_line function withdraw() external { new_line uint256 amount = balances[msg.sender]; new_line require(msg.sender.call.value(amount)()); new_line balances[msg.sender] = 0; new_line } new_line } new_line ", "label": "1"}]